### 详谈判断点在多边形内的七种方法

#### 问题描述

> 给定一个简单多边形 `P` 和一个点 `Q`，请编写一个算法来判断点 `Q` 是否在多边形 `P` 内部。
>
> 输入格式：
>
> - 第一行包含一个整数 `n`，表示多边形 `P` 的顶点数。
> - 接下来 `n` 行，每行两个整数 $x_{i}$ , $y_{i}$，表示多边形 `P` 的第 `i` 个顶点的坐标。
> - 最后一行包含两个整数 $x_{q}$ , $y_{q}$，表示点 `Q` 的坐标。
>
> 输出格式：
>
> - 如果点 `Q` 在多边形 `P` 内部，则输出 `YES`；否则输出 `NO`。

#### 解决方法

###### 方法一：射线法

> 算法描述：
>
> > 以被测点 `Q` 为端点，向任意方向作射线（一般水平向右作射线），统计该射线与多边形的交点数；
> >
> > 如果为奇数，则 `Q` 在多边形内；如果为偶数，则 `Q` 在多边形外；
> >
> > 该算法的时间复杂度为 `O(n)` 。
>
> 特殊情况：
>
> > 很多问题都有边界条件，这种解法也不例外，有一些特殊情况，如图：
> >
> > (a) <img src="https://telegraph-image-6b4.pages.dev/file/3f45dba805c170dfa8c5e.png" style="zoom: 50%;" />
> >
> > (b) <img src="https://telegraph-image-6b4.pages.dev/file/a560363220b0148f738cf.png" style="zoom:58%;" />
> >
> > (c) <img src="https://telegraph-image-6b4.pages.dev/file/c7161ed168002223107d1.png" style="zoom:59%;" />
>
> 解决特殊情况：
>
> > 为了统一起见，射线设定为水平向右，设点 `Q'` 的纵坐标与 `Q` 相同, `Q'` 的横坐标比 `Q` 的横坐标打，则可用 `QQ'` 替代射线。判断算法描述如下：
> >
> > - 首先，对于多边形的水平边不作考虑
> > - 其次，对于多边形的顶点和射线相交的情况，如果该顶点是其所属的边上纵坐标较大的顶点，则计数，否则忽略该点
> > - 最后，对于 `Q` 在多边形边上的情形，直接可判断 `Q` 属于多边行。
>
> 代码评价：
>
> > 最常用方法，比较简单，推荐
>
> 算法代码：
>
> ```c++
> #include <bits/stdc++.h>
> 
> using namespace std;
> 
> class Point {
> public:
>     Point(int val1, int val2) {
>         x = val1;
>         y = val2;
>     }
> 
>     int x;
>     int y;
> };
> 
> void Generate(vector<Point> &pts) {
>     Point p1(-1, 2);
>     pts.push_back(p1);
>     Point p2(-1, -1);
>     pts.push_back(p2);
>     Point p3(2, -1);
>     pts.push_back(p3);
>     Point p4(2, 0);
>     pts.push_back(p4);
>     Point p5(1, 0);
>     pts.push_back(p5);
> }
> 
> bool on_line(Point &start, Point &end, Point &Q) {
>     return (((end.x - Q.x) * (start.x - Q.x) + (end.y - Q.y) * (start.y - Q.y)) <= 0 &&
>             ((end.x - Q.x) * (start.y - Q.y) - (end.y - Q.y) * (start.x - Q.x)) == 0);
> }
> 
> 
> bool InPolygon(vector<Point> &pts, Point Q) {
>     int n = (int) pts.size();
>     bool flag = false;
>     for (int i = 0; i < n; i++) {
>         Point P1 = pts[i];
>         Point P2 = pts[(i + 1) % n];
>         //如果点在多边形某一条边上，直接返回 true
>         if (on_line(P1, P2, Q)) {
>             return true;
>         }
>         //判断射线与多边形交点个数
>         if ((P1.y > Q.y) != (P2.y > Q.y) && (Q.x < (Q.y - P1.y) * (P1.x - P2.x) / (P1.y - P2.y) + P1.x)) {
>             flag = !flag;
>         }
>     }
>     return flag;
> }
> 
> 
> int main() {
>     vector<Point> pts;
>     Generate(pts);
>     Point Q(0, 0);
>     cout << (InPolygon(pts, Q) ? "点在多边形内" : "点不在多边形内") << endl;
>     return 0;
> }
> ```

###### 方法二：角度和判断法

> 算法描述：
>
> > 按照顺时针或逆时针顺序遍历，`pts[i],pts[(i+1)%n]`；
> >
> > 计算线段`Qpts[i]`与线段`Qpts[(i+1)%n]`所成夹角$\theta_{i}$；
> >
> > 判断$\sum_{i}\theta_{i}=2\pi$在一定精度范围内是否成立
> >
> > - 如果成立，则点在多边形内
> > - 如果不成立，则点不在多边形内
> >
> > 该算法的时间复杂度为 `O(n)` 。
>
> 特殊情况：
>
> > (a) <img src="https://telegraph-image-6b4.pages.dev/file/3f45dba805c170dfa8c5e.png" style="zoom: 50%;" />
> >
> > (b) <img src="https://telegraph-image-6b4.pages.dev/file/a560363220b0148f738cf.png" style="zoom:58%;" />
> >
> > (c) <img src="https://telegraph-image-6b4.pages.dev/file/c7161ed168002223107d1.png" style="zoom:59%;" />
>
> 代码评价：
>
> > 对精度要求很高，不推荐

###### 方法三：转角法

>  暂略