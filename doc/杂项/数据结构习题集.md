# 数据结构习题集

#### 第一章：绪论

1. **（书本第3题）起泡排序**
   **试举例说明，在对包含$n$个元素做起泡排序的过程中，可能会出现某元素的起始位置与最终位置相邻，甚至已经出与最终位置，却需要参与$n-1$次交换。**
   解析：
   当数组个数为偶数时：$[\frac{n}{2}+2,\frac{n}{2}+3,\dots,n,\frac{n}{2}+1,1,2,\dots,\frac{n}{2}]$
   当数组个数为奇数时：$[\frac{n+1}{2}+1,\frac{n+1}{2}+2,\dots,n,\frac{n+1}{2}+1,1,2,\dots,\frac{n-1}{2}]$
   
1. **（书本第5题）时间复杂度**
   **随着问题输入规模的不断扩大，同一算法所需的计算时间通常都呈单调递增趋势，但情况亦非总是如此。试举例说明，随着输入规模的扩大，同一算法所需的计算时间可能上下波动。**
   解析：
   例如，对任意整数$n\geqslant2$做素因子分解的一种蛮力算法是，反复地从2到$n$递增地逐一尝试。采用这一算法，通过不同的输入$n$，所需的时间$T(n)$如下表

   |    n     |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | **T(n)** |  1   |  2   |  2   |  4   |  3   |  6   |  3   |

   |    n     |  47  |  48  |  49  |  50  |  51  |  52  |  53  |
   | :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | **T(n)** |  46  |  6   |  12  |  9   |  18  |  14  |  52  |

   |    n     |  62  |  63  |  64  |  65  |  66  |  67  |  68  |
   | :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | **T(n)** |  31  |  10  |  6   |  16  |  13  |  66  |  18  |

   实际上，任意素数$n$都对应于该算法的最坏情况，即$T(n)=n-1=O(n)$，

   而任意形如$n=2^k$的整数都对应于最好的情况，即$T(n)=k=O(logn)$。
   
   因此，该算法的运行时间将在这两种极端情况之间，呈波动形式上下起伏。
   
2. **（书本第20题）Fibonacci数的计算**

   - **试证明，任意算法哪怕只是直接打印输出$fib(n)$，也至少需要$\Omega(n)$的时间。**
   - **请设计一个算法，在$O(logn)$时间内计算出$fib(n)$。**
   - **以上结论是否矛盾，为什么。**

   解析：

   - 从渐进角度看，$fib(n)=\Omega(\Theta^n)$。因此采用任何常数进制展开，$fib(n)$均由$\Omega(n)$个数位组成。这就意味着，即便一直$fib(n)$的数值大小，将该数值逐位打印出来也至少需要$\Omega(n)$时间。

   - 根据$Fibonacci$数的定义，可得到如下形式的递推关系：
     $$
     \begin{pmatrix}
      0 & 1 \\
      1 & 1
     \end{pmatrix}\begin{pmatrix}
     fib(k-1)\\fib(k)
     \end{pmatrix}
     =
     \begin{pmatrix}
     fib(k)\\fib(k+1)
     \end{pmatrix}
     $$
     由此，可进一步得到如下通项公式：
     $$
     \begin{pmatrix}
     fib(n)\\fib(n+1)
     \end{pmatrix}
     =
     \begin{pmatrix}
      0 & 1 \\
      1 & 1
     \end{pmatrix}
     ^n
     \begin{pmatrix}
     fib(0)\\fib(1)
     \end{pmatrix}
     =
     \begin{pmatrix}
      0 & 1 \\
      1 & 1
     \end{pmatrix}
     ^n
     \begin{pmatrix}
     0\\1
     \end{pmatrix}
     $$
     于是，整体运行时间为$O(logn)$。

   - 以上结论在表面上的确构成悖论。究其根源在于，以上对$fib(n)$的时间复杂度分析都假定整数的乘法、位移和打印等基本操作各自只需要$O(1)$时间——即采用所谓的常熟代价准则——而这只是在一定程度上的近似。

1. （**书本第27题）判断算法是否必然终止**

   **递归函数**
   $$
   Ackermann(m,n)=
   \left\{
                \begin{array}{lr}
                n+1 & (if \ m=0)  \\
                Ackermann(m-1,1) & (if \ m\gt0 \ and \ n=0)\\
                Ackermann(m-1,Ackermann(m,n-1)) & (if\ m\gt0 \ and \ n\gt0) 
                \end{array}
   \right.
   $$
   **对于每一$(m,n)$输入，这个算法是否必然终止？**

   解析：

   首先我们对于每一个组合$(m,n)$，定义如下次序：

   > 对于任何(m1,n1)与(m2,n2)，若m1<m2，或者m1=m2且n1<n2，则称前者小于后者，记作(m1,n1)<(m2,n2)。

   由`Ackermann()`函数的定义，任意形如`(0,n)`的输入都会终止。

   不妨假设：对于任意小于`(m,n)`的输入，`Ackermann`函数均会终止。则当输入为`(m,n)`时，函数会触发的递归实例无非以下三种：

   > Ackermann(m - 1, 1)
   >
   > Ackermann(m - 1, *)
   >
   > Ackermann(m, n - 1)

   递归实例返回的数值组合均小于`(m,n`)。

   由假设得，算法必然会终止。

2. （**书本第32题）计算时间复杂度**

   1. ```c++
      void F(int n) {
          for(int i = 1, r = 1; i < n; i <<=r, r<<=1);
      }
      ```

      解析：
      $$
      i=\prod_{t=0}^{k-1} 2^{(2^t)}=2^{\sum_{t=0}^{k-1}2^t}=2^{2^k-1}\lt n
      $$
      解得$k \leqslant loglogn$，因此该函数的时间复杂度为$O(loglogn)$。

   2. ```c++
      void F(int n) {
          for(int i = 1; i < n; i = 1 << i);
      }
      ```

      解析：

      我们可以从反方向分析问题，对于一个整数$n$，反复对其取对数，即令$n=log_2n$，判断去多少次对数之后能使得$n\leqslant 1$。记作$k=log^*n$。

   3. ```c++
      int F(int n) {
          return (n > 0) ? G(G(n - 1)) : 0;
      }
      
      int G(int n) {
          return (n > 0) ? G(n - 1) + 2 * n - 1 : 0; 
      }
      ```

      解析：

      分析可得，函数$F(n),G(n)$实现的功能分别为$F(n)=(n-1)^4,G(n)=n^2$。设$F(n),G(n)$的时间复杂度分别记为$f(n),g(n)$。

      $G(n)$属于线性递归，原理为$G(n)=1+3+\dots+(2n-1)$，时间复杂度为$g(n)=O(n)$。

      $F(n)$调用了两次$G(n)$，因此时间复杂度满足：$f(n)=O(1)+g(n-1)+g((n-1)^2)=O(1)+O(n-1)+O((n-1)^2)=O(n^2)$。

   4. ```c++
      void F(int n) {
          for (int i = 1; i < n / G(i, 0); i++);
      }
      
      void G(int n, int k) {
          return (n < 1) ? k : G(n - 2 * k - 1, k + 1);
      }
      ```

      解析：

      分析可得，函数$G(n)$实现的功能为$G(n)=\lceil n \rceil$。设$F(n),G(n)$的时间复杂度分别记为$f(n),g(n)$。显然$g(n)=O(\lceil n \rceil)$。

      对于函数$F(n)$迭代终止的条件为$i\geqslant n/\lceil i \rceil$，即$i=\Theta(n^{\frac{2}{3}})$。

      因此$F(n)$的时间复杂度满足：$f(n)=O(\sqrt1)+O(\sqrt2)+\dots+O(\sqrt{n^{\frac{2}{3}}})=O(\int_{0}^{n^{\frac{2}{3}}}\sqrt x)=O(n)$。

   5. ```c++
      int F(int n) {
          return (n > 0) ? G(2, F(n - 1) : 1);
      }
      
      int G(int n, int m) {
          return (m > 0) ? n + G(n, m - 1) : 0;
      }
      ```

      答案：$f(n)=O(2^n),g(n,m)=O(m)$。

   6. ```c++
      int F(int n) {
          return (n > 3) ? F(n >> 1) + F(n >> 2) : n;
      }
      ```

      解析：时间复杂度$f(n)$满足$f(0)=f(1)=f(2)=f(3)=1,f(4)=3,f(2)=f(\frac{n}{2}+\frac{n}{4}+1)$。

      **难点**：如何解？

      **提示**：令$s(m)=f(2^m)$。

      答案：$f(n)=O(n^{0.694})$。

#### 第二章：向量

1. **（书本第5题）分摊时间复杂度**
   **设谋算法中有一个无符号32位整型变量$count=b_{31}b_{30}\dotsb_{1}b_{0}$，其功能是作为计数器，不断地递增（$count++$，溢出后循环）。每经一次递增，$count$的某些比特位都会在0和1之间翻转。现考查对$c$连续的足够多次递增操作。试证明：对于每次递增操作，就分摊的意义而言，$count$只有$O(1)$个比特位发生翻转。**
   解析：
   不妨设从0开始，考察该计数器的连续$N>>2$次递增操作。由结论**每经过$2^k$次递增，$b_k$恰好反转一次**，可得所有数位的翻转次数总和为：$\frac{N}{2^{31}}+\frac{N}{2^{30}}+\dots+\frac{N}{4}+\frac{N}{2}+N=N·(\frac{1}{2^{31}}+\frac{1}{2^{30}}+\dots+\frac{1}{4}+\frac{1}{2})\lt2N$，因此分摊时间复杂度为$O(1)$，即单次递增操作仅引发$O(1)$次数位翻转。
   
2. **（书本第36题）$Eratosthenes$筛法**
   **利用$Bitmap$思想设计算法，快速地计算不大于$10^8$得所有素数。**
   解析：
   【解法$A$：$Eratosthenes$筛法】

   ```c++
   const int N = 1e8 + 10;
   bitset<N> pri;
   
   int Eratosthenes(int n) {
       for (int i = 2; i <= n / i; i++) {
           if (!pri[i]) {
               for (int j = i * i; j <= n; j += i) {
                   pri[j] = true;
               }
           }
       }
       int num = 0;
       for (int i = 2; i <= n; i++) {
           if (!pri[i]) {
               num++;
           }
       }
       return num;
   }
   ```
   
   【解法$B$：$Euler$筛法】
   
   ```c++
   const int N = 1e8 + 10;
   bitset<N> pri;
   vector<int> primes;
   int point = 0;
   
   void Euler(int n) {
       for (int i = 2; i <= n; i++) {
           if (!pri[i]) {
               primes.push_back(i);
               point++;
           }
           for (int j = 0; j < point && primes[j] * i <= n; j++) {
               pri[primes[j] * i] = true;
               if (i % primes[j] == 0) {
                   break;
               }
           }
       }
   }
   ```
   
2. **（书本第39题）$CBA$算法考查**
   **任给12个互异的整数，其中10个以组织为一个有序序列，现需要插入剩余两个以完成整体排序。若采用$CBA$式算法，最坏情况下至少需做几次比较？**
   解析：
   将两个数插入序列中，共$11\times12=132$种可能性。因此判定树的高度至少为$h(CT(A))=\lceil log_2132 \rceil=8$。因此最坏情况下至少需做8次比较。

3. **（书本第41题）排序算法有序性**
   **试证明，对于任一$n\times m$的整数矩阵$M$，若首先对每一列分别排序，则继续对每一行分别排序后，其中的割裂将依然有序。**
   解析：
   任取两行向量$A[0,m)$和$B[0,m)$，对于两列元素$A[k],A[k+1],B[k],B[k+1]$，排序后无非四种情况：

   - 若$A[k],A[k+1]$顺序，$B[k],B[k+1]$顺序，显然排序后依然有$A[k]\lt B[k],A[k+1]\lt B[k+1]$

   - 若$A[k],A[k+1]$乱序，$B[k],B[k+1]$乱序，显然排序后依然有$A[k]\lt B[k],A[k+1]\lt B[k+1]$

   - 若$A[k],A[k+1]$顺序，$B[k],B[k+1]$​乱序，则排序后有
     $$
     A'[k]=A[k] \lt B[k] \lt B[k+1]=B'[k]\\
     A'[k+1]=A[k+1] \lt B[k+1]=B'[k] \lt B'[k+1]
     $$

   - 若$A[k],A[k+1]$乱序，$B[k],B[k+1]$​顺序，则排序后有
     $$
     A'[k]\lt A'[k+1]=A[k]\lt B[k]\\
     A'[k+1]=A[k] \lt B[k] \lt B[k+1] = B'[k+1]
     $$
     由选取元素的任意性，命题得证。

#### 第三章：列表

1. **（书本第4题）分析列表的$deduplicate()$函数**

   - **给出其中循环体所具有的不变性，并通过数学归纳予以证明；**
   - **试举例说明，该算法在最好情况下仅需$O(n)$时间；**
   - **试改进该算法，使其时间复杂度降至$O(nlogn)$。**

   解析：

   - 这里的不变性是：在迭代过程中的任意时刻，当前节点$p$的所有前驱互不相同。
     算法开始时，$p$没有前驱，命题成立。
     若当前迭代之后，假设依然成立，考虑下一步迭代：
     - 转到下一个节点$p$
     - 通过$find()$接口查找与当前节点相同的前驱
     - 由与所有前驱满足不变性，因此与$p$相同的前驱至多一个，若存在，调用$remove()$接口删除
     - 当前迭代之后依然满足不变性
     - 由数学归纳原理，任意一步迭代都满足不变性。
   - 考虑列表$List \ L = \left \{ 1,1,1,1,1,1,1,1 \right \} $，去重操作时间复杂度为$O(n)$。但对于一般的列表，时间复杂度为$O(n^2)$。
   - 先调用$sort()$接口对列表进行排序，然后调用$uniquify()$接口对列表进行去重。

2. **（书本第5题）试基于列表的遍历接口$traverse()$实现以下操作：**

   - **$increase()$：所有元素数值加一**
   - **$half()$：所有元素数值减半**

   解析：

   - ```c++
     template <typename T>
     struce Increase {
         virtual void operator()(T &e) {
             e++;
         }
     }
     
     template <typename T>
     void increase(List<T> &L) {
         L.traverse(Increase<T>());
     }
     ```

   - ```c++
     template <typename T>
     struce Half {
         virtual void operator()(T &e) {
             e /= 2;
         }
     }
     
     template <typename T>
     void half(List<T> &L) {
         L.traverse(Half<T>());
     }
     ```

3. **（书本第10题）假定序列中$n$个元素的数值为独立均匀的随机分布，试证明：**

   - **列表的插入排序算法平均需要做约$\frac{n^2}{4}=O(n^2)$次元素比较操作；**
   - **向量的插入排序算法平均要做约$\frac{n^2}{4}=O(n^2)$次元素移动操作；**
   - **序列的插入排序算法过程中平均有$expected-O(logn)$个元素无需移动。**

   解析：

   - 首先，平均意义下的比较操作次数，也就是概率意义下比较操纵的期望次数。
     该算法共需执行$O(n)$步迭代，故根据期望值的线性率，比较操作的总次数的期望值应该等于各步迭代中比较操作次数的期望值之和。
     该算法的比较操作，主要消耗于对有序子列表的$search()$查找过程
     又因为$search()$接口具有线性的平均复杂度，这就意味着，各步迭代内的$search()$过程所涉及的比较操作次数，应从0到$n-1$按算术级数线性递增，故其总和应为：（**因为是平均意义下，所以每次迭代比较为$\frac{k}{2}$**。）
     $$
     \sum_{k=0}^{n-1}\frac{k}{2}=\frac{n*(n-1)}{4}=O(n^2)
     $$

   - 与列表不同，向量的插入排序中$search()$查找接口可以采用二分查找之类的算法，从而使其复杂度从线性降低至$O(logn)$。
     然而从另一方面，在确定适当位置之后将新元素插入到已排序的子序列中，向量最坏情况下需要移动$O(n)$，而就平均意义而言，对于排序过程中的$n$步迭代，总共需要移动次数为：
     $$
     \sum_{k=0}^{n-1}\frac{k}{2}=\frac{n*(n-1)}{2}=O(n^2)
     $$

   - 既然该算法由多步迭代构成，故其间无需移动的元素的期望数目，就等于各步迭代中，待插入元素无需移动的概率之和。
     根据算法原理，对于任一$k\in[0,n)$，在第$k$步迭代启动之初，当前$A[k]$的$k$个前驱应该也已经构成一个有序的子序列$A[0,k)$。不难看出，若$A[k]$无需移动即使得$A[0,k]$仍为有序子序列，则其充要条件是$A[k]$在$A[0,k]$中为最大元素。
     既然假定所有元素都符合独立且均匀的随机分布，故作为前$k+1$个输入元素得普通一员，$A[k]$在其中为最大元素的概率应与其他元素均等，都是$\frac{1}{k+1}$。于是，这一概率的总和为
     $$
     \sum_{k=0}^{n-1}\frac{1}{k+1}=\sum_{k=1}^n\frac{1}{k}=O(logn)
     $$
   
4. （书本第11题）

https://www.bilibili.com/video/BV1Ld4y147YT
