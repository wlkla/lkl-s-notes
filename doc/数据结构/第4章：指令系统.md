
# 第四章：指令系统

## 指令系统

### 指令集体系结构

1. 一台计算机的所有指令的集合构成该机的`指令系统/指令集`。
2. 指令系统是指令集体系结构$(ISA)$中最核心的部分，$ISA$完整定义了软硬件之间的接口。
3. $ISA$规定的内容主要包括：
   - 指令格式、指令寻址方式、操作类型以及每种操作对应的操作数的相关规定
   - 操作数的类型、操作数寻址方式以及数据的大小端存储方式
   - 程序可访问的寄存器编号、个数和位数、存储空间的大小和编制方式
   - 指令执行过程的控制方式

### 指令的基本格式

1. 一条指令通常包括`操作码字段`和`地址码字段`两部分。

   - 操作码指出该指令应执行什么操作以及具有何种功能
   - 地址码给出被操作的信息的地址

2. `指令字长`是指一条指令所包含的二进制代码的位数，其取决于操作码的长度、地址码的长度和地址码的个数。

   指令字长与机器字长没有固定的关系。通常定义：

   - 单字长指令：指令长度等于机器字长的指令
   - 半字长指令：指令长度等于半个机器字长的指令
   - 双字长指令：指令长度等于两个机器字长的指令

3. 若所有指令的长度都相等，则称为`定长指令字结构`；若各种指令的长度随指令功能而异，则称为`变长指令字结构`。因为主存一般是按字节编址的，所以指令字长通常为字节的整数倍。

4. 零地址指令：

   <svg width="500" height="70" xmlns="http://www.w3.org/2000/svg" version="1.1">
    <g>
     <title>Layer 1</title>
     <text fill="#000000" stroke="#000" stroke-width="0" x="98.39999" y="45.99999" id="svg_1" font-size="24" font-family="Noto Sans JP" text-anchor="start" xml:space="preserve">零地址：            OP</text>
     <path fill="none" opacity="undefined" d="m214.39999,14.99999l177,0l0,42l-177,0l0,-42z" id="svg_2" stroke="#000000"/>
    </g>
   - 不需要操作数的指令，如空操作指令、停机指令、关中断指令等
   - 零地址的运算类指令仅用于堆栈计算机中

5. 一地址指令：

   <svg width="500" height="70" xmlns="http://www.w3.org/2000/svg" version="1.1">
    <g>
     <title>Layer 1</title>
     <text style="cursor: move;" xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="24" id="svg_1" y="44.99999" x="45.94886" stroke-width="0" stroke="#000" fill="#000000">一地址：          OP                A1</text>
     <path stroke="#000000" id="svg_2" d="m162.91878,13.99999l282,0l0,42l-282,0l0,-42z" opacity="undefined" fill="none"/>
     <line stroke="#000000" id="svg_4" y2="55.07895" x2="297.36283" y1="14.15064" x1="297.36283" fill="none"/>
    </g>
   - 只有目的操作数的单操作数指令，按$A_1$地址读取操作数，进行$OP$操作后，结果存回原地址。
     指令含义：$OP(A_1)\rightarrow A_1$
   - 隐含约定目的地址的双操作数指令，按指令地址$A_1$可读取源操作数，指令可隐含约定另一个操作数由$ACC$提供，运算结果也将存放在$ACC$中。
     指令含义：$(ACC)OP(A_1)\rightarrow ACC$
   - 若地址字段均为主存地址，则完成一条一地址指令需要三次访存：取指令+取操作数+存结果

6. 二地址指令：

   <svg width="500" height="70" xmlns="http://www.w3.org/2000/svg" version="1.1">
    <g>
     <title>Layer 1</title>
     <text style="cursor: move;" xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="24" id="svg_1" y="44.99999" x="50.76172" stroke-width="0" stroke="#000" fill="#000000">二地址：     OP         A1         A2</text>
     <path stroke="#000000" id="svg_2" d="m153.97829,15.19467l282,0l0,42l-282,0l0,-42z" opacity="undefined" fill="none"/>
     <line stroke="#000000" id="svg_4" y2="56.4874" x2="252.63496" y1="15.55909" x1="252.63496" fill="none"/>
     <line stroke="#000000" id="svg_3" y2="56.67349" x2="345.32902" y1="14.34273" x1="345.32902" fill="none"/>
    </g>

   - 指令含义：$(A_1)OP(A_2)\rightarrow A_1$
     对于常用的算术和逻辑运算指令，往往需要使用两个操作数，需要分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果
   - 若地址码字段均为主存地址，则完成一条二地址指令需要四次访存：取指令+去操作数+去操作数+存结果

7. 三地址指令：

   <svg width="500" height="70" xmlns="http://www.w3.org/2000/svg" version="1.1">
    <g>
     <title>Layer 1</title>
     <text style="cursor: move;" fill="#000000" stroke="#000" stroke-width="0" x="45.95401" y="44.99999" id="svg_1" font-size="24" font-family="Noto Sans JP" text-anchor="start" xml:space="preserve">三地址：     OP      A1      A2      A3</text>
     <path stroke="#000000" fill="none" opacity="undefined" d="m149.17058,15.19467l302.67316,0l0,42l-302.67316,0l0,-42z" id="svg_2"/>
     <line fill="none" x1="235.29085" y1="15.55909" x2="235.29085" y2="56.4874" id="svg_4" stroke="#000000"/>
     <line stroke="#000000" fill="none" x1="309.32607" y1="15.50891" x2="309.32607" y2="56.67349" id="svg_3"/>
     <line id="svg_5" y2="56.78362" x2="379.35958" y1="15.46653" x1="379.35958" stroke="#000000" fill="none"/>
    </g>

   - 指令含义：$(A_1)OP(A_2)\rightarrow A_3$
   - 若地址码字段均为主存地址，则完成一条三地址指令需要四次访存：取指令+去操作数+去操作数+存结果

8. 四地址指令：

   <svg width="499.99999999999994" height="70" xmlns="http://www.w3.org/2000/svg" version="1.1">
    <g>
     <title>Layer 1</title>
     <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="24" id="svg_1" y="44.99999" x="24.52923" stroke-width="0" stroke="#000" fill="#000000">四地址：  OP      A1      A2      A3     A4</text>
     <path stroke="#000000" id="svg_2" d="m123.74582,15.19467l348.67315,0l0,42l-348.67315,0l0,-42z" opacity="undefined" fill="none"/>
     <line stroke="#000000" id="svg_4" y2="56.4874" x2="192.81298" y1="15.55909" x1="192.81298" fill="none"/>
     <line id="svg_3" y2="56.67349" x2="266.40572" y1="15.50891" x1="266.40572" fill="none" stroke="#000000"/>
     <line fill="none" stroke="#000000" x1="340.42153" y1="15.46653" x2="340.42153" y2="56.78362" id="svg_5"/>
     <line id="svg_6" y2="57.65012" x2="409.91143" y1="15.53097" x1="409.91143" stroke="#000000" fill="none"/>
    </g>

   - 指令含义：$(A_1)OP(A_2)\rightarrow A_3, A_4=$​下一条将要执行指令的地址
   - 若地址码字段均为主存地址，则完成一条四地址指令需要四次访存：取指令+去操作数+去操作数+存结果

### 定长操作码指令格式

1. 定长操作码指令在指令字的最高位部分分配固定的若干位表示操作码。
2. 定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。

### 扩展操作码指令格式

1. 可变长度操作码指全部指令的操作码字段的位数不固定，且分散的放在指令字的不同位置上。
2. 最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需求的前提下，有效地缩短指令字长。
3. 在设计扩展操作码指令格式时，需要注意：
   - 不允许短码是长码的前缀
   - 各指令的操作码一定不能重复

### 指令的操作类型

1. 数据传送
   - 传送指令通常有寄存器之间的传送$(MOV)$、从内存单元读取数据到$CPU$寄存器$(LOAD)$、从$CPU$寄存器写数据到内存单元$(STORE)$、进栈操作$(PUSH)$、出栈操作$(POP)$等。
2. 算术和逻辑运算
   - 这类指令主要有加$(ADD)$、减$(SUB)$、乘$(MUL)$、除$(DIV)$、加一$(INC)$、减一$(DEC)$、与$(AND)$、或$(OR)$、取反$(NOT)$、异或$(XOR)$等
3. 移位操作
   - 移位指令主要有算术移位、逻辑移位、循环移位。
4. 转移操作
   - 转移指令主要有无条件转移$(JMP)$，条件转移$(BRANCH)$，调用$(CALL)$，返回$(RET)$，陷阱$(TRAP)$等。
   - 调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址，当子程序执行结束后，根据返回地址返回到主程序继续执行；而转移指令则不执行返回。
5. 输入输出操作
   - 这类指令用于完成$CPU$​与外部设备交换数据或传送控制命令及状态信息。

### 错题

1. 某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令$29$条、二地址指令$107$条，每个地址字段为$6$位，则指令字长至少应该是（）位

   A. $24$

   B. $26$

   C. $28$

   D. $32$​

2. 在一个$36$位长的指令系统中，设计一个扩展操作码，使之能表示下列指令：

   - $7$条具有两个$15$位地址和一个$3$位地址的指令；
   - $500$条具有一个$15$位地址和一个$3$位地址的指令；
   - $50$条无地址指令

## 指令的寻址方式

### 指令寻址和数据寻址

1. 寻找下一条将要执行的指令地址称为`指令寻址`；寻找本条指令的数据地址称为`数据寻址`。

2. 指令寻址：有两种方式：`顺序寻址方式`和`跳跃寻址方式`

   - 顺序寻址方式：通过程序计数器$PC$加一，自动形成下一条指令的地址。
   - 跳跃寻址方式：通过转移类指令实现。由于$CPU$总是根据$PC$的内容去主存取指令的，因此转移指令执行的结果是修改$PC$的值，下一条指令仍然通过$PC$​给出。

3. 数据寻址

   - 数据寻址的方式较多，为区别各种方式，通常在指令字中设置一个`寻址特征`字段，用来指明寻址方式，因此指令的格式为：

     <svg width="500" height="70" xmlns="http://www.w3.org/2000/svg" version="1.1">
      <g>
       <title>Layer 1</title>
       <rect id="svg_1" height="45.35544" width="438.25376" y="12.04905" x="27.15998" stroke="#000" fill="none"/>
       <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="24" stroke-width="0" id="svg_2" y="44.88138" x="68.46719" stroke="#000" fill="#000000">操作码      寻址特征      形式地址A</text>
       <line id="svg_3" y2="56.74077" x2="158.88135" y1="11.61017" x1="158.88135" stroke="#000" fill="none"/>
       <line id="svg_4" y2="56.74586" x2="301.59322" y1="11.61017" x1="301.59322" stroke="#000" fill="none"/>
      </g>

   - 指令中的地址码字段并不代表操作数的真实地址，这种地址称为`形式地址(A)`。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为`有效地址(EA)`。

### 常见的数据寻址方式

1. 隐含寻址

   - 这种类型的指令不明显给出操作数的地址，而是隐含操作数的地址。
   - 优点：有利于缩短指令字长
   - 缺点：需增加存储操作数或隐含地址的硬件

2. 立即寻址

   - 指令字中的地址字段指出的不是操作数的地址，而是操作数本身，也称`立即数`，采用补码表示。
   - 优点：指令在执行阶段不访存，指令执行速度最快
   - 缺点：操作数的位数限制了立即数的范围

3. 直接寻址

   - 指令字中的形式地址就是操作数的真实地址。
   - 优点：简单，不需要专门计算操作数的地址，指令在执行阶段仅需访存一次
   - 缺点：形式地址的位数限制了该指令操作数的寻址范围，操作数的地址不易修改

4. 间接寻址

   - 指令的地址字段给出的不是操作数的真实地址，而是操作数有效地址所在主存单元的地址，也就是操作数地址的地址。
   - 优点：可扩大寻址范围，便于编程
   - 缺点：在执行阶段要多次访存

5. 寄存器寻址

   - 与直接寻址的原理一样，只是把访问主存改为访问寄存器，指令的地址字段给出的是操作数所在寄存器的编号。

6. 寄存器间接寻址

   - 综合了间接寻址和寄存器寻址各自的特点，指令字中所指的寄存器给出的不是一个操作数，而是操作数所在主存单元的地址。
   - 优点：既扩大了寻址范围，又减少了访存次数，在执行阶段仅需访存一次。

7. 偏移寻址：相对寻址

   - 把$PC$的内容加上指令格式中的形式地址而形成操作数的有效地址。其中形式地址是相对于当前$PC$值得`偏移量`，可正可负。
   - 优点：操作数的地址不是固定的，它随$PC$值得变化而变化，且与指令地址之间总是相差一个固定的偏移量，因此便于程序浮动。
   - 相对寻址广泛应用于`转移指令`。

8. 偏移寻址：基址寻址

   - 基址寻址是指将基址寄存器$(BR)$的内容加上指令字中的形式地址而形成操作数得有效地址。
   - 主要用于解决程序逻辑空间与存储空间的无关性。在程序执行过程中，基址寄存器的内容不变，作为基地址，形式地址可变，作为偏移量。
   - 优点：可以扩大寻址范围，有利于多道程序设计，并可用于编制浮动程序
   - 缺点：偏移量的位数较短

9. 偏移寻址：变址寻址

   - 变址寻址是指将变址寄存器$(IX)$的内容加上指令字中的形式地址而形成操作数的有效地址。
   - 在程序执行过程中，变址寄存器的内容可由用户改变，作为偏移量，形式地址不变，作为基地址。
   - 优点：可扩大寻址范围，适合编制循环程序。偏移量的位数足以表示整个存储空间。

   > [!IMPORTANT]
   >
   > 变址寻址与基址寻址的区别：
   >
   > - 基址寻址面向系统，主要用于为多道程序或数据分配存储空间。$BR$中数据不可变，形式地址可变
   > - 变址寻址面向用户，主要用于处理数组问题。$IX$中数据可变，形式地址不可变。

   

10. 堆栈寻址

    - 堆栈中读写单元的地址是用一个特定寄存器给出的，该寄存器成为堆栈指针$(SP)$。
    - 堆栈分为硬堆栈和软堆栈。硬堆栈是指用寄存器管理数据，软堆栈是指从主存中划取一部分管理数据。
    - 在堆栈计算机中，大部分指令都是无操作数指令，因为操作数地址都隐含使用$SP$，在读写堆栈前后都伴有自动完成对$SP$的加减操作。

11. 寻址方式总结：

    | 寻址方式 | 有效地址 | 访存次数 |
    | :------: | :------: | :------: |
    | 立即寻址           | $A$即为操作数 | $0$      |
    | 直接寻址           | $EA=A$        | $1$      |
    | 一次间接寻址       | $EA=(A)$      | $2$      |
    | 寄存器寻址         | $EA=R_i$      | $0$      |
    | 寄存器间接一次寻址 | $EA=(R_i)$    | $1$      |
    | 相对寻址           | $EA=(PC)+A$   | $1$      |
    | 基址寻址           | $EA=(BR)+A$   | $1$      |
    | 变址寻址           | $EA=(IX)+A$   | $1$      |


### 错题

1. 指令系统中采用不同寻址方式的目的是（）

   A. 提供扩展操作码的可能性并降低指令译码的难度

   B. 可缩短指令字长，扩大寻址空间，提高编程的灵活性

   C. 实现程序控制

   D. 三者都正确

2. 设指令中的地址码为$A$，变址寄存器为$X$，程序计数器为$PC$，则变址间址寻址方式的操作数的有效地址$EA$是（）

   A. $((PC)+A)$

   B. $((X)+A)$

   C. $(X)+(A)$

   D. $(X)+A$

3. 指令寻址方式有顺序和跳跃两种，采用跳跃寻址方式可以实现（）

   A. 程序浮动

   B. 程序的无条件浮动和条件浮动

   C. 程序的无条件转移和条件转移

   D. 程序的调用

4. 某计算机的字长为$16$位，指令$MOV \ R1, \ \left[R2\right]$的功能是把内存数据传送到寄存器$R1$，寻址方式位寄存器间接寻址。$R2$的值为$1234H$，内存单元$1234H$存放数据$56H$，内存单元$1235H$存放数据$78H$，采用小端存储。则执行指令后$R1$的值为（）

   A. $5678H$

   B. $7856H$

   C. $8765H$

   D. $6587H$

5. 对按字寻址的机器，程序计数器和指令寄存器的位数各取决于（）

   A. 机器字长，存储器的字数

   B. 存储器的字数，指令字长

   C. 指令字长，机器字长

   D. 地址总线宽度，存储器的字数

6. 某计算机按字节编址，采用大端方式，某指令的一个操作数的机器数为$ABCD \ 00FFH$，该操作数采用基址寻址方式，指令中形式地址（用补码表示）为$FF00H$，当前基址寄存器的内容为$C000 \ 0000H$，则该操作数的$LSB$存放的地址为（）

   A. $C000 \ FF00H$

   B. $C000 FF03H$

   C. $BFFF \ FF00H$

   D. $BFFF \ FF03H$

## 程序的机器级代码表示

### 常用的汇编指令介绍

1. 相关寄存器（$32$位）：$EAX$，$EBX$，$ECX$，$EDX$，$ESI$，$EDI$，$EBP$，$ESP$​

   - 为了向后兼容，$EAX$，$EBX$，$ECX$和$EDX$的高两位字节和地两位字节可以独立使用。例如$EAX$的低两位字节称为$AX$，而$AX$的高低字节又可分别作为两个$8$位寄存器，分别成为$AH$和$AL$。
   
     <svg width="500" height="70" xmlns="http://www.w3.org/2000/svg" version="1.1">
      <g>
       <title>Layer 1</title>
       <rect stroke="#000" fill="none" x="32.15998" y="13.04905" width="438.25376" height="45.35544" id="svg_1"/>
       <line fill="none" stroke="#000" x1="251" y1="12.61017" x2="251" y2="57.74077" id="svg_3"/>
       <line fill="none" stroke="#000" x1="357.59322" y1="12.61017" x2="357.59322" y2="57.74586" id="svg_4"/>
       <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="12" stroke-width="0" id="svg_2" y="26.99999" x="17.39999" stroke="#000" fill="#000000">31                                                         16  15                      8  7                          0</text>
       <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="27" id="svg_5" y="48.99999" x="289.39998" stroke-width="0" stroke="#000" fill="#000000">AH         AL</text>
      </g>

2. 汇编指令格式：$AT\&T$格式和$Intel$格式

   |                            |                         $AT\&T$格式                          |                         $Intel$格式                          |
   | :------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
   | 目的操作数$d$，源操作数$s$ |       $op \ s,d$<br />注：源操作数在左，目的操作数在右       |      $op \ d ,s$<br />注：源操作数在右，目的操作数在左       |
   |        寄存器的表示        |     $mov \ \%ebx, \ \%eax$<br />注：寄存器名前必须加$\%$     |       $mov \ eax,\ ebx$<br />注：直接写寄存器名字即可        |
   |        立即数的表示        |    $mov \ \$985, \ \%eax$<br />注：立即数之前必须加“$\$$”    |          $mov \ eax, \ 985$<br />注：直接写数字即可          |
   |       主存地址的表示       |         $mov \ \%eax, \ (af996h)$<br />注：用小括号          |           $mov \ [af996h],\ eax$<br />注：用中括号           |
   |       读写长度的表示       | $movb \ \$5, \ (af996h)$<br />$movw \ \$5, \ (af996h)$<br />$movl \ \$5, \ (af996h)$<br />$addb \ \$4,\ (af996h)$<br />注：指令后加$b$，$w$，$l$分别表示读写长度为$byte$，$word$，$dword$ | $mov \ byte \ ptr \ [af996h], \ 5$<br />$mov \ word \ ptr \ [af996h], \ 5$<br />$mov \ dword \ ptr \ [af996h], \ 5$<br />$add \ byte \ ptr \ [af996h], \ 5$<br />注：在主存地址之前说明读写长度为$byte$，$word$，$dword$ |
   |    主存地址偏移量的表示    | $mov \ -8(\%ebx), \ \% eax$<br />注：偏移量（基址）<br />$mov \ 4(\%ebx, \ \%eax, \ 32), \ \%eax$<br />注：偏移量（基址，变址，比例因子） | $mov \ eax, \ [ebx-8]$<br />注：[基址+偏移量]<br />$mov \ eax, \ [ebx+ecx \times 32+4]$<br />注：[基址+变址*比例因子+偏移量] |

3. 常用指令：汇编指令通常可分为`数据传送指令`，`算术和逻辑运算指令`和`控制流指令`。

   > $<reg>$：表示任意寄存器，若其后带有数字，则指定其位数。$<reg32>$表示$32$位寄存器$(eax,ebx,ecx,edx,esi,edi,esp,ebp)$；$<reg16>$表示$16$位寄存器$(ax,bx,cx,dx)$；$<reg8>$表示$8$位寄存器，$(ah,al,bh,bl,ch,cl,dh,dl)$。
   >
   > $<mem>$：表示内存地址。
   >
   > $<con>$：表示$8$位、$16$位或$32$位常数。$<con8>$表示$8$位常数。

   - 数据传送指令：$mov$指令：将第二操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数（寄存器或内存）。双操作数指令的两个操作数不能都是内存。若需要在内存之间复制，可先从内存复制到一个寄存器，再从寄存器复制到内存。

     > $mov \ <reg>, \ <reg>$
     >
     > $mov \ <reg>, \ <mem>$
     >
     > $mov \ <mem>, \ <reg>$
     >
     > $mov \ <reg>, \ <con>$
     >
     > $mov \ <mem>, \ <con>$

   - 数据传送指令：$push$指令：将操作数压入内存的栈，常用于函数调用。$ESP$是栈顶，入栈前先将$ESP$的值减四，然后将操作数压入$ESP$​指示的地址。

     > $push \ <reg32>$
     >
     > $push \ <mem>$
     >
     > $push \ <con32>$

   - 数据传送指令：$pop$指令：出栈前先将$ESP$指示的地址中的内容出栈，然后将$ESP$​值加四。

     > $pop \ <reg32>$
     >
     > $pop \ <mem>$
     >
     > $pop \ <con32>$

   - 算术和逻辑运算指令：$add/sub$​指令：指令将两个操作数相加/减，然后将结果保存到第一个操作数中。

     > $add \ <reg>, \ <reg>/sub \ <reg>, \ <reg>$
     >
     > $add \ <reg>, \ <mem>/sub \ <reg>, \ <mem>$
     >
     > $add \ <mem>, \ <reg>/sub \ <mem>, \ <reg>$
     >
     > $add \ <reg>, \ <con>/sub \ <reg>, \ <con>$
     >
     > $add \ <mem>, \ <con>/sub \ <mem>, \ <con>$

   - 算术和逻辑运算指令：$inc/dec$指令：将操作数自加一、自减一。

     > $inc \ <reg>/dec \ <reg>$
     >
     > $inc \ <mem>/dec \ <mem>$

   - 算术和逻辑运算指令：$imul$指令：有符号整数乘法指令，有两种格式：

     两个操作数：将两个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须是寄存器

     > $imul \ <reg32>, \ <mem32>$
     >
     > $imul \ <reg32>, \ <mem>$

     三个操作数：将第二个和第三个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须是寄存器

     > $imul \ <reg32>, \ <reg32>, \ <con>$
     > $imul \ <reg32>, \ <mem>, \ <con>$

   - 算术和逻辑运算指令：$idiv$指令：有符号整数的除法指令，他只有一个操作数，即除数，而被除数则为$edx:eax$中的内容，操作结果有两部分：商和余数，商送至$eax$，余数送至$edx$​。

     > $idiv \ <reg32>$
     >
     > $idiv \ <mem>$

   - 算术和逻辑运算指令：$and/or/xor$指令：$and$、$or$、$xor$​指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。

     > $and \ <reg>, \ <reg>/or \ <reg>, \ <reg>/xor \ <reg>, \ <reg>$
     >
     > $and \ <reg>, \ <mem>/or \ <reg>, \ <mem>/xor \ <reg>, \ <mem>$
     >
     > $and \ <mem>,\ <reg>/or \ <mem>,\ <reg>/xor \ <mem>, \ <reg>$
     >
     > $and \ <reg>,\ <con>/or \ <reg>,\ <con>/xor \ <reg>,\ <con>$
     >
     > $and \ <mem>, \ <con>/or \ <mem>, \ <con> / xor \ <mem>,\ <con>$

   - 算术和逻辑运算指令：$not$​指令：位翻转指令，将操作数中的每一位取反。

     > $not \ <reg>$
     >
     > $not \ <mem>$

   - 算术和逻辑运算指令：$neg$​指令：取反指令。

     > $neg \ <reg>$
     >
     > $neg \ <mem>$

   - 算术和逻辑运算指令：$shl/shr$指令：逻辑移位指令，$shl$为逻辑左移，$shr$​为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数

     > $shl \ <reg>, \ <con8>/shr \ <reg>, \ <con8>$
     >
     > $shl \ <mem>,\ <con8>/shr \ <mem>, \ <con8>$
     >
     > $shl \ <reg>,\ <cl>/shr \ <reg>,\ <cl>$
     >
     > $shl \ <mem>,\ <cl>/shr \ <mem>,\ <cl>$

   - 控制流指令：$jmp$指令：控制程序计数器$IP$无条件转移到$label$所指示的地址。
   
     > $jmp \ <label>$
   
   - 控制流指令：$j\textit{condition}$指令：条件转移指令，依据$CPU$状态字中的一系列条件状态转移。
   
     > $je \ <label> \ (jump \ while \ equal)$ #若a=b，则跳转，ZF=1？
     >
     > $jz \ <label> \ (jump \ while \ last \ result \ was \ zero)$ #若a≠b则跳转，ZF≠0？
     >
     > $jne \ <label> \ (jump \ while \ not \ equal)$ 
     >
     > $jg \ <label> \ (jump \ while \ greater \ than)$ #若a>b则跳转，ZF=0&SF=OF?
     >
     > $jge \ <label> \ (jump \ while \ greater \ than \ or \ equal \ to)$ #若a≥b则跳转，SF=OF？
     >
     > $jl \ <label> \ (jump \ while \ less \ than)$ #若a<b则跳转，SF≠OF?
     >
     > $jle \ <label> \ (jump \ while \ less \ than \or \ equal \ to)$ #若a≤b则跳转，SF≠OF|ZF=1？
   
   - 控制流指令：$cmp/test$指令：$cmp$指令相当于$sub$指令，用于比较两个操作数的值。$test$指令相当于$and$指令，用于对两个操作数进行逐位与运算。根据运算结果修改$CPU$状态字中的条件码。
   
     > $cmp \ <reg>, \ <reg>/test \ <reg>, \ <reg>$
     >
     > $cmp \ <reg>, \ <mem>/test \ <reg>, \ <mem>$
     >
     > $cmp \ <mem>,\ <reg>/test \ <mem>,\ <reg>$
     >
     > $cmp \ <reg>, \ <con>/test \ <reg>, \ <con>$​
   
   - 控制流指令：$call/ret$指令：$call$指令首先将当前指令地址入栈，然后无条件转移到由标签指示的指令，同时需要保存调用之前的地址信息。$ret$指令实现子程序的返回i机制，$ret$指令弹出栈中保存的指令地址，然后无条件转移到保存的的指令地址执行。
   
     > $call \ <label>$
     >
     > $ret$​
     
     $call$指令的作用：
     
     - 将`IP旧值`压栈保存（保存在函数的栈帧顶部）
     - 设置`IP新值`，无条件转移至被调用函数的第一条指令
     
     $ret$指令的作用：
     
     - 从函数的栈帧顶部找到`IP旧值`，将其出栈并恢复$IP$寄存器
   

### 选择语句的机器级表示

1. 常见的算术逻辑指令$(add,sub,imul,or,and,shl,inc,dec,not,sal)$会设置条件码，还有$cmp$和$test$指令只设置条件码而不改变任何其他寄存器。

2. 根据条件码$ZF$和$SF$来判断条件，然后结合$jcondition$指令实现条件跳转。

3. $if-else$语句的通用形式为：

   ```c++
   if (test_expr)
       then_statement
   else 
       else_statement
   ```

   被翻译为的汇编语句格式为：

   ```
   t = test_expr
   if (t)
   	goto true
   else_statement
   goto done
   true:
   	then_statement
   done:
   ```


### 循环语句的机器级表示

1. $do-while$​循环通用格式如下：

   ```
   do
   	body_statement
   	while(test_expr)
   ```

   被翻译为的汇编语句格式为：

   ```
   loop:
   	body_statement
   	t = test_expr;
   	if (t)
   		goto loop;
   ```

2. $while$循环通用格式如下：

   ```
   while (test_expr)
   	body_statement
   ```

   被翻译为的汇编语句格式为：

   ```
   t = test_expr;
   if (!t)
   	goto done;
   loop:
   	body_statement
   	t = test_expr;
   	if (t)
   		goto loop
   done:
   ```

   > [!CAUTION]
   >
   > 如果使用$loop$命令实现，则对于循环计数器，只能使用$ecx$。

3. $for$循环通用格式如下：

   ```
   for (init_expr; test_expr; update_expr) 
   	body_statement
   ```

   被翻译为的汇编语句格式为：

   ```
   init_expr;
   t = test_expr
   if (!t)
   	goto done;
   loop:
   	body_statement
   	update_expr
   	t = test_expr
   	if (t)
   		goto loop
   done:
   ```

### 过程调用的机器级表示

1. 假定过程$P$（调用者）调用过程$Q$（被调用者），调用过程的执行步骤如下：

   - $P$将入口参数（实参）放到$Q$能访问到的地方
   - $P$将返回地址存到特定的地方，然后将控制转移到$Q$
   - $Q$保存$P$的现场，并为自己的非静态局部变量分配空间
   - 执行过程$Q$
   - $Q$恢复$P$的现场，将返回结果放到$P$能访问到的地方，并释放局部变量所占空间
   - $Q$取出返回地址，将控制转移到$P$

2. 因为寄存器被共享，为了程序能正确运行，有如下规范：

   - 寄存器$EAX$、$ECX$、$EDX$是调用者保存寄存器，当$P$调用$Q$时，若$Q$需要用到这些寄存器，则由$P$将内容保存到栈中，并在返回后由$P$恢复它们的值。
   - 寄存器$EBX$、$ESI$、$EDI$是被调用者保存寄存器，当$P$调用$Q$时，$Q$必须先将这些寄存器的内容保存到栈中才能使用它们，并在返回$P$之前先恢复它们的值。

3. 每个过程都有自己的栈区，称为`栈帧`，因此，一个栈由若干个栈帧组成。$EBP$指示栈帧的起始位置，$ESP$​指示栈顶。

   > 在$X86$系统中，默认以$4$​字节为栈的操作单位。

4. 栈帧的组成：

   - 栈帧最底部一定是上一层栈帧基址（$ebp$旧值）
   - 栈帧最顶部一定是返回地址
   - 通常将局部变量集中存储在栈帧底部区域
   - 通常将调用参数集中存储在栈帧顶部区域

   ![image-20240515202652086](C:\Users\33580\AppData\Roaming\Typora\typora-user-images\image-20240515202652086.png)

### 错题

1. 某$C$语言程序段在计算机$M$上的部分机器级代码如下，数组$a$的定义为`int a[24][64]`，每个机器级代码行中依此包含指令序号、虚拟地址、机器指令和汇编指令

   ```
      for (i = 0; i < 24; i++)
   1  00401072    C7 45 F8 00 00 00 00    mov [ebp - 8], 0
   2  00401079    EB 09                   jmp 00401084h
   3  0040107B    8B 55 F8                mov eax, [ebp - 8]
      ......      ......                  ......
   7  00401088    7D 32                   jge 004010bch
         for (j = 0; j < 64; j++)
   8  0040108A    C7 45 FC 00 00 00 00    mov [ebp - 4], 0
      ......      ......                  ......
            a[i][j] = 10;
      ......      ......                  ......
   19 004010AE    C7 84 82 00 20 42 00 0A 00 00 00    mov [ecx + edx * 4 + 00422000h], 0Ah
   20 ......      ......                  ......
   ```

   请回答下列问题：

   - 第$20$条指令的虚拟地址是多少？
   - 已知第$2$条$jmp$和第$7$条$jge$都是跳转指令，其操作码分别是$EBH$和$7DH$，跳转目标地址分别为$0040 \ 1084H$、$0040 \ 10BCH$，这两条指令都采用什么寻址方式？给出第$2$条指令$jmp$的跳转目标地址计算过程。
   - 已知第$19$条$mov$指令的功能为$a[i][j]\leftarrow10$，其中$ecx$和$edx$为寄存器名，$0042 \ 2000H$是数组$a$的首地址，指令中源操作数采用什么寻址方式？已知$edx$中存放的是变量$j$，$ecx$中存放的是什么？根据该指令的机器码判断$M$采用的是大端还是小端方式。
   - 第一次执行第$19$条指令时，取指令过程中是否会发生缺页异常？为什么？

## $CISC$和$RISC$的基本概念

### 基本概念

1. 复杂指令系统计算机：增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化。
2. 精简指令系统计算机：减少指令种类和简化指令功能，提高指令的执行速度。

### $CISC$与$RISC$的比较

1. |                  | $CISC$                               | $RISC$                               |
   | ---------------- | ------------------------------------ | ------------------------------------ |
   | 指令系统         | 复杂                                 | 简单                                 |
   | 指令数目         | 一般大于两百条                       | 一般小于一百条                       |
   | 指令字长         | 不固定                               | 固定                                 |
   | 可访存指令       | 不加限制                             | 仅$LOAD/STORE$指令                   |
   | 各种指令执行时间 | 相差较大                             | 绝大多数可在一个周期内完成           |
   | 各种指令使用频度 | 相差很大                             | 都比较常用                           |
   | 通用寄存器数量   | 较少                                 | 多                                   |
   | 目标代码         | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效 |
   | 控制方式         | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制               |
   | 指令流水线       | 可以通过一定方式实现                 | 必须实现                             |

   